#!/usr/bin/env ruby
# encoding: utf-8

=begin
****************************************************************************

  Apti is a frontend for aptitude with improved presentation of packages.

  Copyright (C) 2012-2013 by Florent Lévigne <florent.levigne at mailoo dot com>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

****************************************************************************
=end

# Configuration in ~/.config/apti/aptirc.rb (by default)

APTI_VERSION      = "0.3-dev (2013-10-21)"
$VERBOSE          = true  # enable warnings
COLOR_END         = "\e[0m"
NEED_SUPERUSER_RIGHTS = ["install", "remove", "purge", "hold", "unhold", "keep", "reinstall",
                         "markauto", "unmarkauto", "build-depends", "build-dep", "forbid-version",
                         "update", "safe-upgrade", "full-upgrade", "keep-all", "forget-new",
                         "clean", "autoclean"]


#-----------------------------#
#          functions          #
#-----------------------------#

#
# Display help.
#
# @return [void]
#
def help
  puts "usage: #{File.basename $0} commande"
  puts "Commandes:"
  puts "  update"
  puts "  safe-upgrade"
  puts "  search package"
  puts "  install package"
  puts "  remove package"
  puts "  others aptitude commande..."
  puts "  --stats"
end


#
# Display version.
#
# @return [void]
#
def version
  puts "apti #{APTI_VERSION}"
end


#
# Separate packages in analysis parts
#
# @param packages [Array<String>] list of packages
# @return [Hash{String => Fixnum}] largest size of "name", "version", and "size"
#
def analysis_packages packages
  max                   = Hash.new
  max['name']           = 0
  max['version']        = Hash.new
  max['version']['old'] = 0
  max['version']['new'] = 0
  max['size']           = Hash.new
  max['size']['before'] = 0
  max['size']['after']  = 0
  max['size']['unit']   = 0

  details = Array.new

  packages.each do |package|
    # ex: brasero-common{a} [3.8.0-2] <+11,2 MB
    #                     name          parameter           version_old        ->     version_new                size_before         size_after      size_unit
    if package =~ /^([[:alnum:]+.:]*)(\{[:alpha:]\})? \[([[:alnum:]+.:~-]*)(?: -> ([[:alnum:]+.:~-]*))?\](?: <([+-]?[[:digit:] ]+)([.,][:digit:]+)? ([:alpha:]+)>)?$/
      detail                   = Hash.new
      detail['name']           = $1
      detail['parameter']      = $2
      detail['version']        = Hash.new
      detail['version']['old'] = $3
      detail['version']['new'] = $4
      detail['size']           = Hash.new
      detail['size']['before'] = $5
      detail['size']['after']  = $6
      detail['size']['unit']   = $7

      if detail['name'].length > max['name']
        max['name'] = detail['name'].length;
      end

      if detail['version']['old'].length > max['version']['old']
        max['version']['old'] = detail['version']['old'].length;
      end
      if not detail['version']['new'].nil? and detail['version']['new'] > max['version']['new']
        max['version']['new'] = detail['version']['new'].length
      end

      if not detail['size']['before'].nil? and detail['size']['before'].length > max['size']['before']
        max['size']['before'] = detail['size']['before'].length
      end
      if not detail['size']['after'].nil? and detail['size']['after'].length > max['size']['after']
        max['size']['after'] = detail['size']['after'].length
      end
      if not detail['size']['unit'].nil? and detail['size']['unit'].length > max['size']['unit']
        max['size']['unit'] = detail['size']['unit'].length
      end
    
      details << detail
    end
  end

  max['version']['all'] = max['version']['old'] + max['version']['new'] + " -> ".length

  out            = Hash.new
  out['max']     = max
  out['details'] = details

  return out
end


#
# Print header for install, remove and upgrade.
#
# @param largest_name [Fixnum]
# @param largest_version [Fixnum]
# @param display_version [Boolean]
# @return [void]
#
def print_header(largest_name, largest_version, display_version = true)
  terminal_width  = `tput cols`.to_i

  # Ligne du haut
  terminal_width.times do
    print '='
  end
  print "\n"

  # Nom des colonnes
  header_package = "Package"
  header_version = "Version"
  header_size    = "Size"

  print "  #{header_package}#{header_version.rjust((largest_name + header_package.length) + $space_between_columns)}"
  if $display_packages_size and display_version
    print "#{header_size.rjust((largest_version['all'] - header_version.length) + $space_between_columns)}"
  end
  print "\n"

  # Ligne du bas
  terminal_width.times do
    print '='
  end
  print "\n"
end


#
# Execute the command with superuser rights if needed.
#
# @param command [String]
# @param no_confirm [Boolean]
# @return [void]
#
def execute_command(command, no_confirm = false)

  if not NEED_SUPERUSER_RIGHTS.include? command.split[1]
    system command

  elsif `groups`.split.include? "sudo"
    if no_confirm and $no_confirm
      system "sudo #{command} --assume-yes"
    else
      system "sudo #{command}"
    end

  else
    if no_confirm and $no_confirm
      system "su -c '#{command} --assume-yes'"
    else
      system "su -c '#{command}'"
    end
  end
end


#
# upgrade
#
# @param packages [String]
# @param full_upgrade [Boolean]
# @return [void]
#
def upgrade(packages, full_upgrade = false)
  if full_upgrade
    aptitude_string = `aptitude full-upgrade -Vs --allow-untrusted --assume-yes #{packages}`
    command = "aptitude full-upgrade #{packages}"
  else
    aptitude_string = `aptitude safe-upgrade -Vs --allow-untrusted --assume-yes #{packages}`
    command = "aptitude safe-upgrade #{packages}"
  end

  # if problem with dependencies, use aptitude
  if aptitude_string.include? "1)"
    execute_command command
    exit 0

  # if there is no package to upgrade
  elsif not aptitude_string.include? ':'
    puts "System is up to date."
    exit 0
  end

  packages = [[]]

  first_install = false
  first_remove  = false
  first_update  = false

  # split packages
  packages = aptitude_string.split ']'

  max             = get_max_package packages
  largest_name    = max["name"]
  largest_version = max["version"]

  print_header(largest_name, largest_version, false)

  packages.each do |ele|

    # if we have a package to install
    # ex: freepats{a} [20060219-1
    if ele =~ /(([[:alnum:]]|-|\+|\.|:)*)(\{a\}) \[(.*)/
      package_name    = $1
      package_version = $4

      if not first_install
        puts "\033[1mInstalling:\033[0m"
        first_install = true
      end

      print "  #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.length + $spaces_between_columns).times do
        print ' '
      end

      puts "#{$color_install}#{package_version}#{COLOR_END}"

    # if we have a package to remove
    # ex: gcj-4.6-base{u} [4.6.3-1]
    elsif ele =~ /(([[:alnum:]]|-|\+|\.|:)*)(\{u\}) \[(.*)/
      package_name    = $1
      package_version = $4

      if not first_remove
        puts "\n\033[1mRemoving:\033[0m"
        first_remove = true
      end

      print "  #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.length + $spaces_between_columns).times do
        print ' '
      end

      puts "#{$color_remove}#{package_version}#{COLOR_END}"

    # if we have a package to upgrade
    # ex: php5 [5.3.10-2 -> 5.4.0-3
    elsif ele =~ /(([[:alnum:]]|-|\+|\.|:)*) \[(.*) -> (.*)/

      package_name        = $1
      version_installed   = $3
      version_to_install  = $4

      if not first_update
        puts "\n\033[1mUpdating:\033[0m"
        first_update = true
      end

      # package name
      print "  #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.length + $spaces_between_columns).times do
        print ' '
      end

      # version installed
      print "#{$color_remove}#{version_installed}#{COLOR_END} "

      # print spaces between version installed and version to install
      (largest_version - version_installed.length).times do
        print ' '
      end

      # version to install
      puts "-> #{$color_install}#{version_to_install}#{COLOR_END}"
    end
  end

  # size to download and install
  puts "\n#{aptitude_string.split(/\n/)[-2]}"

  answer = ''
  while (not answer.downcase.eql? 'y') and (not answer.downcase.eql? 'n')
    print "\n\033[1mContinue the upgrade ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  if not answer.downcase.eql? 'n'
    execute_command(command, true)
  end
end


#
# search
#
# @param package [String]
# @return [void]
#
def search package
  aptitude_string = `aptitude search --disable-columns #{package}`
  terminal_width  = `tput cols`.to_i
  package_info_length = 6 # information size (i, p, A, ...) : 6 seems to be good

  # for each package
  aptitude_string.each_line do |package_line|

    package_str = package_line.split "- "

    package_name = package_str.first # ex: i A aptitude-common
    package_description = ""

    # construct the description (all after the first '-')
    name_passed = false
    package_str.each do |str|
      if not name_passed
        name_passed = true
      else
        package_description.concat "- #{str }"
      end
    end

    # informations of the package: i, p, A, ...
    package_info = package_name.split
    package_info.pop
    package_info = package_info.join(' ')

    # just the package name (without informations)
    package_name = package_name.split.last

    # display package informations
    print package_info

    # print spaces between package_info and package_name
    (package_info_length - package_info.length).times do
      print ' '
    end

    # display package name: if the package is installed, we display it in color
    if package_info.include? 'i'
      print "#{$color_install}#{package_name}#{COLOR_END}"
    else
      print package_name
    end

    # print spaces between package_name and package_description
    ($spaces_search - package_name.length).times do
      print ' '
    end

    size_of_line = package_info_length + $spaces_search + package_description.length

    # if description is too long, we shorten it
    if size_of_line > terminal_width
      package_description = package_description[0..(terminal_width - package_info_length - $spaces_search - 1)]
    end

    # display the description
    puts "#{$color_description}#{package_description.chomp}#{COLOR_END}"
  end
end


#
# install
#
# @param package [String]
# @return [void]
#
def install package
  aptitude_string = `aptitude install -VZs --allow-untrusted --assume-yes #{package}`
  command = "aptitude install #{package}"

  # if problem with dependencies, wrong name given,
  # or trying to install a virtual package : use aptitude
  if aptitude_string.include? "1)" or aptitude_string.include? '«'
    execute_command command
    exit 0

  # if the package is already installed
  elsif not aptitude_string.include? ':'
    puts "Package(s) already installed."
    exit 0
  end

  packages = [[]]

  first_install_explicitly = false
  first_install_as_dep = false

  # split packages
  packages = aptitude_string.split(/ {2}/)

  packages_installed_explicitly = packages.reject { |package| package =~ /\{a\}/ }
  packages_installed_as_dep = packages - packages_installed_explicitly

  packages = packages_installed_explicitly + packages_installed_as_dep

  analysis = analysis_packages packages
  max      = analysis['max']
  details  = analysis['details']
  
  print_header(max['name'], max['version'])

  packages.each do |ele|

    # if we have a package to install
    # ex: brasero [3.8.0-2] <+1 113 kB> or  brasero{a} [3.8.0-2] <+1 113 kB>
    if ele =~ /(([[:alnum:]]|-|\+|\.|:)*)(\{a\})? \[(.*)\] <(.*)/
      package_name          = $1
      package_install_auto  = $3
      package_version       = $4
      package_size          = $5

      if not first_install_explicitly
        puts "\033[1mInstalling:\033[0m"
        first_install_explicitly = true
      end

      if (not first_install_as_dep) and (not package_install_auto.nil?)
        puts "\n\033[1mInstalling for dependencies:\033[0m"
        first_install_as_dep = true
      end

      print "  #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.length + $spaces_between_columns).times do
        print ' '
      end

      print "#{$color_install}#{package_version}#{COLOR_END}"

      if $display_packages_size
        # print spaces between version and size
        (largest_version - package_version.length + $spaces_between_columns).times do
          print ' '
        end
        
        if package_size =~ /^([+-]?[0-9\s]+)((?:\.|,)[0-9]+)?\s+([a-z]+)$/i
          size_before = $1
          size_after  = $2
          size_unit   = $3
        end

  if size_after.nil?
          size_after_length = 0
  else
          size_after_length = size_after.length
  end

        print "#{$color_description}#{size_before.rjust largest_size_before}#{size_after}#{size_unit.rjust(largest_size_unit + largest_size_after - size_after_length + $spaces_between_unit)}#{COLOR_END}"
      end

      print "\n"

    end
  end

  # size to download and install
  puts "\n#{aptitude_string.split(/\n/)[-2]}"

  answer = ''
  while (not answer.downcase.eql? 'y') and (not answer.downcase.eql? 'n')
    print "\n\033[1mContinue the installation ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  if not answer.downcase.eql? 'n'
    execute_command(command, true)
  end
end


#
# remove
#
# @param package [String]
# @param purge [Boolean]
# @return [void]
#
def remove(package, purge = false)
  if purge
    aptitude_string = `aptitude purge -VZs --assume-yes #{package}`
    command = "aptitude purge #{package}"
  else
    aptitude_string = `aptitude remove -VZs --assume-yes #{package}`
    command = "aptitude remove #{package}"
  end

  # if problem with dependencies, wrong name given,
  # or trying to remove a virtual package : use aptitude
  if aptitude_string.include? "1)" or aptitude_string.include? '«'
    execute_command command
    exit 0

  # if the package is not installed
  elsif not aptitude_string.include? ':'
    puts "Package(s) not installed."
    exit 0
  end

  packages = [[]]

  first_remove_explicitly = false
  first_remove_dep = false

  # split packages
  packages = aptitude_string.split '>'

  if purge
    packages_removed_explicitly = packages.reject { |pack| not pack =~ /\{p\}/ }
  else
    packages_removed_explicitly = packages.reject { |pack| pack =~ /\{u\}/ }
  end

  packages_removed_as_dep = packages - packages_removed_explicitly

  packages = packages_removed_explicitly + packages_removed_as_dep

  max             = get_max_package packages
  largest_name    = max["name"]
  largest_version = max["version"]
  largest_size    = max["size"]

  print_header(largest_name, largest_version)

  packages.each do |ele|

    # if we have a package to remove
    # ex: freepats{u} [20060219-1] <-1 113 kB> or freepats [20060219-1] <-1 113 kB>
    if ele =~ /(([[:alnum:]]|-|\+|\.|:)*)(\{u\})?(\{p\})? \[(.*)\] <(.*)/
      package_name        = $1
      package_remove_dep  = $3
      package_version     = $5
      package_size        = $6

      if not first_remove_explicitly
        if purge
          puts "\033[1mPurging:\033[0m"
        else
          puts "\033[1mRemoving:\033[0m"
        end
        first_remove_explicitly = true
      end

      if (not first_remove_dep) and (not package_remove_dep.nil?)
        puts "\n\033[1mRemoving unused dependencies:\033[0m"
        first_remove_dep = true
      end

      print "  #{package_name}"

      # print spaces between name and version of the package
      (largest_name - package_name.strip.length + $spaces_between_columns).times do
        print ' '
      end

      print "#{$color_remove}#{package_version}#{COLOR_END}"

      if $display_packages_size
        # print spaces between version and size
        (largest_version - package_version.length + $spaces_between_columns).times do
          print ' '
        end

        print "#{$color_description}#{package_size.rjust largest_size}#{COLOR_END}"
      end

      print "\n"

    end
  end

  # size free
  puts "\n#{aptitude_string.split(/\n/)[-2]}"

  answer = ''
  while (not answer.downcase.eql? 'y') and (not answer.downcase.eql? 'n')
    print "\n\033[1mRemove these packages ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  if not answer.downcase.eql? 'n'
    execute_command(command, true)
  end
end


#
# Print stats about packages.
#
# @return [void]
#
def stats
  packages_installed            = `dpkg --get-selections | grep install | grep -v deinstall | wc -l`
  packages_installed_explicitly = `aptitude search '~i !~M' | wc -l`
  cache_size                    = `du -sh /var/cache/apt/archives/ | cut -f 1`

  puts "#{`lsb_release -ds`}\n"

  puts "Total installed packages:         #{packages_installed}"
  puts "Explicitly installed packages:    #{packages_installed_explicitly}"
  puts "Space used by packages in cache:  #{cache_size}"
end


#
# Write configuration file.
#
# @param config_dir [String]
# @return [void]
#
def write_config config_dir
  require "fileutils"

  config = "# colors\n" +
    "color_install      : \"\\e[1;32m\" # green\n" +
    "color_remove       : \"\\e[1;31m\" # red\n" +
    "color_description  : \"\\e[1;30m\" # gray\n\n" +
    "# config\n" +
    "display_packages_size  : true   # display or not the size of packages (only for install and remove)\n" +
    "spaces_between_columns : 2      # minimum 1\n" +
    "spaces_between_unit    : 2      # spaces between size and unit\n" +
    "spaces_search          : 40     # spaces with \"search\" between package name and his description\n" +
    "no_confirm             : false  # if true, don't ask for confirmation\n"


  if not File.directory? "#{config_dir}/apti"
    FileUtils.mkdir_p "#{config_dir}/apti"
  end

  File.open("#{config_dir}/apti/aptirc.yml", "w") do |f|
    f.write(config)
  end
end


#
# Read configuration file.
#
# @param config_dir [String]
# @return [void]
#
def read_config config_dir
  require "yaml"

  app_config = YAML::load_file "#{config_dir}/apti/aptirc.yml"

  $color_install          = app_config["color_install"]
  $color_remove           = app_config["color_remove"]
  $color_description      = app_config["color_description"]
  $display_packages_size  = app_config["display_packages_size"]
  $spaces_between_columns = app_config["spaces_between_columns"]
  $spaces_between_unit    = app_config["spaces_between_unit"]     # Espace entre la taille du paquet et son unité 
  $spaces_search          = app_config["spaces_search"]
  $no_confirm             = app_config["no_confirm"]
end


#
# Return the config directory.
#
# @return [String]
#
def get_config_dir
  if ENV["XDG_CONFIG_HOME"].nil?
    return "#{ENV["HOME"]}/.config"
  else
    return ENV["XDG_CONFIG_HOME"]
  end
end



#-----------------------------#
#          execution          #
#-----------------------------#

config_dir = get_config_dir

if not File.exist?("#{config_dir}/apti/aptirc.yml")
  write_config config_dir
end

read_config config_dir


packages = ""
first_argv_passed = false
ARGV.each do |package|
  if not first_argv_passed
    first_argv_passed = true
  else
    packages.concat " #{package}"
  end
end

case ARGV[0]

when "safe-upgrade"
  upgrade packages

when "upgrade"
  puts "Warning: upgrade is deprecated, use safe-upgrade."
  upgrade packages

when "full-upgrade"
  upgrade(packages, true)

when "search"
  search packages

when "update"
  execute_command "aptitude update"

when "remove"
  remove packages

when "purge"
  remove(packages, true)

when "install"
  install packages

when "--stats"
  stats

when "--help"
  help
when "-h"
  help

when "--version"
  version

# other aptitude command
else
  if not ARGV[0].eql? nil
    arg = ""
    ARGV.each do |ele|
      arg.concat "#{ele} "
    end
    execute_command "aptitude #{arg}"
  else
    help
  end

end
