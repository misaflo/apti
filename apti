#!/usr/bin/env ruby
# encoding: utf-8

=begin
****************************************************************************

  Apti is a frontend for aptitude with improved presentation of packages.

  Copyright (C)
    2012-2013 by Florent Lévigne <florent.levigne at mailoo dot com> and
    2013 by Julien Rosset <jul.rosset at gmail dot com>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

****************************************************************************
=end

# Configuration in ~/.config/apti/aptirc.rb (by default)

APTI_VERSION      = "0.3-dev"
$VERBOSE          = true  # enable warnings
COLOR_END         = "\e[0m"
NEED_SUPERUSER_RIGHTS = ["install", "remove", "purge", "hold", "unhold", "keep", "reinstall",
                         "markauto", "unmarkauto", "build-depends", "build-dep", "forbid-version",
                         "update", "safe-upgrade", "full-upgrade", "keep-all", "forget-new",
                         "clean", "autoclean"]


#-----------------------------#
#          functions          #
#-----------------------------#

#
# Display help.
#
# @return [void]
#
def help
  puts "usage: #{File.basename $0} commande"
  puts "Commandes:"
  puts "  update"
  puts "  safe-upgrade"
  puts "  search package"
  puts "  install package"
  puts "  remove package"
  puts "  others aptitude commande..."
  puts "  --stats"
end


#
# Display version.
#
# @return [void]
#
def version
  puts "apti #{APTI_VERSION}"
end


#
# Separate packages in analysis parts
#
# @param packages [Array<String>] list of packages
# @return [Hash{String => Fixnum}] largest size of "name", "version", and "size"
#
def analysis_packages packages
  max                   = Hash.new
  max['name']           = 0
  max['version']        = Hash.new
  max['version']['old'] = 0
  max['version']['new'] = 0
  max['size']           = Hash.new
  max['size']['before'] = 0
  max['size']['after']  = 0
  max['size']['unit']   = 0

  details = Array.new

  packages.delete_if { |package| package == '' || package == "\n" }

  packages.each do |package|
    # ex: brasero-common{a} [3.8.0-2] <+11,2 MB>
    #                     name           parameter           version_old         ->     version_new                size_before         size_after         size_unit
    if package =~ /^([[:alnum:]+.:-]*)(?:\{([[:alpha:]])\})? \[([[:alnum:]+.:~-]*)(?: -> ([[:alnum:]+.:~-]*))?\](?: <([+-]?[[:digit:] ,]+?)([.,][[:digit:]]+)? ([[:alpha:]]+)>)?$/
      detail                   = Hash.new
      detail['name']           = $1
      detail['parameter']      = $2
      detail['version']        = Hash.new
      detail['version']['old'] = $3
      detail['version']['new'] = $4
      detail['size']           = Hash.new
      detail['size']['before'] = $5
      detail['size']['after']  = $6
      detail['size']['unit']   = $7

      if detail['name'].length > max['name']
        max['name'] = detail['name'].length;
      end

      if detail['version']['old'].length > max['version']['old']
        max['version']['old'] = detail['version']['old'].length;
      end
      if not detail['version']['new'].nil? and detail['version']['new'].length > max['version']['new']
        max['version']['new'] = detail['version']['new'].length
      end

      if not detail['size']['before'].nil? and detail['size']['before'].length > max['size']['before']
        max['size']['before'] = detail['size']['before'].length
      end
      if not detail['size']['after'].nil? and detail['size']['after'].length > max['size']['after']
        max['size']['after'] = detail['size']['after'].length
      end
      if not detail['size']['unit'].nil? and detail['size']['unit'].length > max['size']['unit']
        max['size']['unit'] = detail['size']['unit'].length
      end
    
      details << detail
    #else
      #print "Fail to analyse package : #{package}\n"
    end
  end

  max['version']['all'] = max['version']['old'] + max['version']['new']
  if max['version']['new'] > 0
    max['version']['all'] += " -> ".length
  end

  out            = Hash.new
  out['max']     = max
  out['details'] = details

  return out
end


def display_packages(packages, operation, color, question, download_size)
  analysis = analysis_packages packages
  max      = analysis['max']
  details  = analysis['details']

  explicit    = []
  dep_install = []
  dep_remove  = []
  #dep_upgrade = []
  
  details.each do |detail|
    case detail['parameter']
    when 'a'
      dep_install << detail

    when 'u'
      dep_remove  << detail

    #when ''
      #dep_upgrade << detail
      
    else
      explicit << detail
    end
  end

  print_header(max['name'], max['version'])

  puts "\033[1m#{operation} :\033[0m"
  explicit.each { |detail| display_package_line(detail, max, color) }

  if not dep_install.empty?
    puts "\n\033[1mInstalling for dependencies :\033[0m"
    dep_install.each { |detail| display_package_line(detail, max, $color_install) }
  end

  #if not dep_upgrade.empty?
    #puts "\n\033[1mUpdating for dependencies :\033[0m"
    #dep_upgrade.each { |detail| display_package_line(detail, max, $color_remove) }
  #end

  if not dep_remove.empty?
    puts "\n\033[1mRemoving for dependencies :\033[0m"
    dep_remove.each { |detail| display_package_line(detail, max, $color_remove) }
  end

  # size to download and install
  puts "\n#{download_size}"

  answer = ''
  while (not answer.downcase.eql? 'y') and (not answer.downcase.eql? 'n')
    print "\n\033[1m#{question} ? (Y/n)\033[0m "
    answer = STDIN.gets.chomp
    if answer.empty?
      answer = 'y'
    end
  end

  return (not answer.downcase.eql? 'n')
end

def display_package_line(line, max, color)
  print "  #{line['name']}"
  print "#{color}#{''.rjust((max['name'] - line['name'].length) + $spaces_between_columns)}#{line['version']['old']}#{COLOR_END}"

  if not line['version']['new'].nil?
    print "#{' -> '.rjust((max['version']['old'] - line['version']['old'].length) + ' -> '.length)}#{$color_install}#{line['version']['new']}#{COLOR_END}"
  end

  if $display_packages_size and not line['size']['before'].nil?
    line_size_after_length = (line['size']['after'].nil? ? 0 : line['size']['after'].length)

    print "#{$color_description}"
    print "#{line['size']['before'].rjust((max['version']['all'] - line['version']['old'].length) + $spaces_between_columns + max['size']['before'])}"
    print "#{line['size']['after']}"
    print "#{line['size']['unit'].rjust((max['size']['after'] - line_size_after_length) + (max['size']['unit'] - line['size']['unit'].length) + line['size']['unit'].length + $spaces_between_unit)}"
    print "#{COLOR_END}"
  end
  
  print "\n"
end


#
# Print header for install, remove and upgrade.
#
# @param largest_name [Fixnum]
# @param largest_version [Fixnum]
# @param display_version [Boolean]
# @return [void]
#
def print_header(largest_name, largest_version, display_version = true)
  terminal_width  = `tput cols`.to_i

  # Ligne du haut
  terminal_width.times do
    print '='
  end
  print "\n"

  # Nom des colonnes
  header_package = "Package"
  header_version = "Version"
  header_size    = "Size"

  print "  #{header_package}"
  print "#{''.rjust(largest_name - header_package.length + $spaces_between_columns)}"
  print "#{header_version}"
  if $display_packages_size and display_version
    print "#{''.rjust(largest_version['all'] - header_version.length + $spaces_between_columns + 1)}"
    print "#{header_size}"
  end
  print "\n"

  # Ligne du bas
  terminal_width.times do
    print '='
  end
  print "\n"
end


#
# Execute the command with superuser rights if needed.
#
# @param command [String]
# @param no_confirm [Boolean]
# @return [void]
#
def execute_command(command, no_confirm = false)

  if not NEED_SUPERUSER_RIGHTS.include? command.split[1]
    system command

  elsif `groups`.split.include? "sudo"
    if no_confirm and $no_confirm
      system "sudo #{command} --assume-yes"
    else
      system "sudo #{command}"
    end

  else
    if no_confirm and $no_confirm
      system "su -c '#{command} --assume-yes'"
    else
      system "su -c '#{command}'"
    end
  end
end


#
# upgrade
#
# @param packages [String]
# @param full_upgrade [Boolean]
# @return [void]
#
def upgrade(packages, full_upgrade = false)
  if full_upgrade
    aptitude_string = `aptitude full-upgrade -Vs --allow-untrusted --assume-yes #{packages}`
    command = "aptitude full-upgrade #{packages}"
  else
    aptitude_string = `aptitude safe-upgrade -Vs --allow-untrusted --assume-yes #{packages}`
    command = "aptitude safe-upgrade #{packages}"
  end
 
  # if problem with dependencies, use aptitude
  if aptitude_string.include? "1)"
    execute_command command
    exit 0

    # if there is no package to upgrade
  elsif not aptitude_string.include? ':'
    puts "System is up to date."
    exit 0
  end

  packages = [[]]

  # split packages
  packages = aptitude_string.split(/ {2}/)

  if display_packages(packages, 'Upgrading', $color_remove, 'Continue the upgrade', aptitude_string.split(/\n/)[-2])
    execute_command(comand, true)
  end
end


#
# search
#
# @param package [String]
# @return [void]
#
def search package
  aptitude_string = `aptitude search --disable-columns #{package}`
  terminal_width  = `tput cols`.to_i
  package_info_length = 6 # information size (i, p, A, ...) : 6 seems to be good

  # for each package
  aptitude_string.each_line do |package_line|

    package_str = package_line.split "- "

    package_name = package_str.first # ex: i A aptitude-common
    package_description = ""

    # construct the description (all after the first '-')
    name_passed = false
    package_str.each do |str|
      if not name_passed
        name_passed = true
      else
        package_description.concat "- #{str }"
      end
    end

    # informations of the package: i, p, A, ...
    package_info = package_name.split
    package_info.pop
    package_info = package_info.join(' ')

    # just the package name (without informations)
    package_name = package_name.split.last

    # display package informations
    print package_info

    # print spaces between package_info and package_name
    (package_info_length - package_info.length).times do
      print ' '
    end

    # display package name: if the package is installed, we display it in color
    if package_info.include? 'i'
      print "#{$color_install}#{package_name}#{COLOR_END}"
    else
      print package_name
    end

    # print spaces between package_name and package_description
    ($spaces_search - package_name.length).times do
      print ' '
    end

    size_of_line = package_info_length + $spaces_search + package_description.length

    # if description is too long, we shorten it
    if size_of_line > terminal_width
      package_description = package_description[0..(terminal_width - package_info_length - $spaces_search - 1)]
    end

    # display the description
    puts "#{$color_description}#{package_description.chomp}#{COLOR_END}"
  end
end


#
# install
#
# @param package [String]
# @return [void]
#
def install package
  aptitude_string = `aptitude install -VZs --allow-untrusted --assume-yes #{package}`
  command = "aptitude install #{package}"

  # if problem with dependencies, wrong name given,
  # or package already installed : display aptitude's message
  if (aptitude_string.include? "1)") or (not aptitude_string.include? ':')
    puts aptitude_string
    exit 0
  end

  packages = [[]]

  # split packages
  packages = aptitude_string.split(/ {2}/)
  
  if display_packages(packages, 'Installing', $color_install, 'Continue the installation', aptitude_string.split(/\n/)[-2])
    execute_command(command, true)
  end
end


#
# remove
#
# @param package [String]
# @param purge [Boolean]
# @return [void]
#
def remove(package, purge = false)
  if purge
    aptitude_string = `aptitude purge -VZs --assume-yes #{package}`
    command = "aptitude purge #{package}"

    operation = "Purging"
  else
    aptitude_string = `aptitude remove -VZs --assume-yes #{package}`
    command = "aptitude remove #{package}"

    operation = "Removing"
  end

  # if problem with dependencies, wrong name given,
  # or trying to remove a virtual package : display aptitude's message
  if (aptitude_string.include? "1)") or (aptitude_string.include? '«')
    puts aptitude_string
    exit 0

  # if the package is not installed
  elsif not aptitude_string.include? ':'
    puts "Package(s) not installed."
    exit 0
  end

  # Remove the "p" paraleter on packages to purge
  aptitude_string.sub!(/\{p\}/, '')

  packages = [[]]

  # split packages
  packages = aptitude_string.split(/ {2}/)

  if display_packages(packages, operation, $color_remove, operation + ' these packages', aptitude_string.split(/\n/)[-2])
    execute_command(command, true)
  end
end


#
# Print stats about packages.
#
# @return [void]
#
def stats
  packages_installed            = `dpkg --get-selections | grep install | grep -v deinstall | wc -l`
  packages_installed_explicitly = `aptitude search '~i !~M' | wc -l`
  cache_size                    = `du -sh /var/cache/apt/archives/ | cut -f 1`

  puts "#{`lsb_release -ds`}\n"

  puts "Total installed packages:         #{packages_installed}"
  puts "Explicitly installed packages:    #{packages_installed_explicitly}"
  puts "Space used by packages in cache:  #{cache_size}"
end


#
# Write configuration file.
#
# @param config_dir [String]
# @return [void]
#
def write_config config_dir
  require "fileutils"

  config = "# colors\n" +
    "color_install      : \"\\e[1;32m\" # green\n" +
    "color_remove       : \"\\e[1;31m\" # red\n" +
    "color_description  : \"\\e[1;30m\" # gray\n\n" +
    "# config\n" +
    "display_packages_size  : true   # display or not the size of packages (only for install and remove)\n" +
    "spaces_between_columns : 2      # minimum 1\n" +
    "spaces_between_unit    : 2      # spaces between size and unit\n" +
    "spaces_search          : 40     # spaces with \"search\" between package name and his description\n" +
    "no_confirm             : false  # if true, don't ask for confirmation\n"


  if not File.directory? "#{config_dir}/apti"
    FileUtils.mkdir_p "#{config_dir}/apti"
  end

  File.open("#{config_dir}/apti/aptirc.yml", "w") do |f|
    f.write(config)
  end
end


#
# Read configuration file.
#
# @param config_dir [String]
# @return [void]
#
def read_config config_dir
  require "yaml"

  app_config = YAML::load_file "#{config_dir}/apti/aptirc.yml"

  $color_install          = app_config["color_install"]
  $color_remove           = app_config["color_remove"]
  $color_description      = app_config["color_description"]
  $display_packages_size  = app_config["display_packages_size"]
  $spaces_between_columns = app_config["spaces_between_columns"]
  $spaces_between_unit    = app_config["spaces_between_unit"]     # Espace entre la taille du paquet et son unité 
  $spaces_search          = app_config["spaces_search"]
  $no_confirm             = app_config["no_confirm"]
end


#
# Return the config directory.
#
# @return [String]
#
def get_config_dir
  if ENV["XDG_CONFIG_HOME"].nil?
    return "#{ENV["HOME"]}/.config"
  else
    return ENV["XDG_CONFIG_HOME"]
  end
end



#-----------------------------#
#          execution          #
#-----------------------------#

config_dir = get_config_dir

if not File.exist?("#{config_dir}/apti/aptirc.yml")
  write_config config_dir
end

read_config config_dir


packages = ""
first_argv_passed = false
ARGV.each do |package|
  if not first_argv_passed
    first_argv_passed = true
  else
    packages.concat " #{package}"
  end
end

case ARGV[0]

when "safe-upgrade"
  upgrade packages

when "upgrade"
  puts "Warning: upgrade is deprecated, use safe-upgrade."
  upgrade packages

when "full-upgrade"
  upgrade(packages, true)

when "search"
  search packages

when "update"
  execute_command "aptitude update"

when "remove"
  remove packages

when "purge"
  remove(packages, true)

when "install"
  install packages

when "--stats"
  stats

when "--help"
  help
when "-h"
  help

when "--version"
  version

  # other aptitude command
else
  if not ARGV[0].eql? nil
    arg = ""
    ARGV.each do |ele|
      arg.concat "#{ele} "
    end
    execute_command "aptitude #{arg}"
  else
    help
  end

end
